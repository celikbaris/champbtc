Of course. Here is the complete `README.md` file documenting the entire project.

---

# 🏆 Champion Trader Bot

This repository contains the complete source code and documentation for a high-performance, systematic trading bot for BTC/USDT on a 3-minute timeframe. The strategy is built on a machine learning model (XGBoost) that analyzes market micro-structure to predict short-term price movements, combined with a robust risk management and backtesting framework.

The backtest of the final, tuned algorithm over a 5-year period showed a **+1420.49%** return on investment.

## Project Structure

The project is organized into a clean, professional structure to separate concerns like code, configuration, data, and generated artifacts.

```
champion_trader/
├── data/
│   └── btc_usdt_5y_1m.csv
│
├── models/
│   ├── champion_long_model.json
│   └── champion_short_model.json
│
├── reports/
│   ├── champion_bot_final_report.html
│   └── trade_log.csv
│
├── src/
│   ├── trainer.py
│   ├── live_bot.py
│   ├── dashboard.py
│   ├── notifications.py
│   ├── update_data.py
│   ├── initial_data_fetcher.py
│   └── config.py
│
├── .gitignore
├── config.ini
├── requirements.txt
└── README.md
```

-   **/data**: Contains the raw 1-minute historical price data for BTC/USDT.
-   **/models**: Stores the trained XGBoost models (`.json` files) generated by the `trainer.py` script.
-   **/reports**: Stores the HTML backtest reports and the CSV log of all paper trades.
-   **/src**: Contains all Python source code.
    -   `trainer.py`: The core algorithm backtester and model trainer.
    -   `live_bot.py`: The live trading bot that executes the strategy.
    -   `dashboard.py`: A Streamlit web application to monitor the bot in real-time.
    -   `notifications.py`: Handles sending trade notifications via Telegram.
    -   `update_data.py`: A utility to update the historical data with the latest candles.
    -   `initial_data_fetcher.py`: A one-time script to download the full historical dataset from Binance.
    -   `config.py`: A module that loads and provides settings from `config.ini`.
-   **config.ini**: Main configuration file for API keys, Telegram credentials, and all trading parameters.
-   **requirements.txt**: A list of all required Python packages for easy setup.
-   **.gitignore**: Prevents sensitive files like `config.ini` and large data files from being committed to version control.
-   **README.md**: This documentation file.

---

## The Algorithm: How It Works

The strategy is a multi-stage process designed to find a high-probability "edge" in the market and exploit it with strict risk controls.

### 1. Data Preparation and Timeframe

The core insight of the winning strategy is that a model trained on **3-minute candles that have been resampled from 1-minute data** performs significantly better than a model trained directly on 3-minute data. This resampling process likely smooths noise and creates more consistent patterns for the model to learn.

-   **Base Timeframe:** 1-minute (`1m`)
-   **Strategy Timeframe:** 3-minute (`3min`)

### 2. Feature Engineering

For each 3-minute candle, the algorithm calculates a set of features to describe the current market state:

-   **Momentum:**
    -   Log returns (`returns`)
    -   Lagged returns for the last 1, 2, 3, 5, and 10 candles.
    -   Moving averages of returns (`momentum_5`, `momentum_10`).
-   **Volatility:**
    -   Standard deviation of returns (`volatility_10`).
    -   A **Volatility Filter** (`volatility_filter`) which is a 50-period moving average of the 10-period volatility. This helps the bot avoid trading in quiet, choppy markets.
-   **Price Action (Candle Structure):**
    -   Percentage of the candle that is the body vs. the total range (`body_pct`).
    -   Size of the upper and lower wicks as a percentage of the range (`upper_wick_pct`, `lower_wick_pct`).
-   **Order Flow:**
    -   The ratio of aggressive "taker" buys to total volume (`taker_buy_ratio`). This is a proxy for buying pressure.

### 3. The Prediction Models

The "brain" of the algorithm consists of two separate **XGBoost Regressor** models:

1.  **The Long Model:** This model is trained to predict the maximum potential upside over the next 5 candles (15 minutes). Its target is `(future_high - current_close) / current_close`.
2.  **The Short Model:** This model is trained to predict the maximum potential downside over the next 5 candles. Its target is `(current_close - future_low) / current_close`.

Using two separate specialist models proved more effective than a single model trying to predict both directions.

### 4. Entry Conditions (The "Edge")

A trade is only initiated if all of the following conditions are met:

1.  **Volatility Check:** The current 10-period volatility must be greater than 80% of the 50-period volatility filter. This confirms the market is active enough to trade.
2.  **Prediction Threshold:** The relevant model's prediction must exceed a specific threshold. The optimal values found through testing are:
    -   **Long Entry:** `predicted_long > 0.005` (0.5%)
    -   **Short Entry:** `predicted_short > 0.005` (0.5%)
3.  **Signal Clarity:** To avoid contradictory signals, a long trade is only entered if the short model's prediction is *not* also above its threshold, and vice-versa.

### 5. Risk Management & Position Sizing

This is the most critical component for ensuring long-term survival and profitability.

1.  **Risk per Trade:** The bot uses a **Fixed Fractional** position sizing model, risking a small, fixed percentage (**2%**) of its current total capital on any single trade.
2.  **Stop-Loss:** The initial stop-loss is placed dynamically based on market volatility. It is set at **2 times the Average True Range (ATR)** away from the entry price.
3.  **Position Size Calculation:** The exact trade size is calculated to ensure that if the stop-loss is hit, only the predetermined 2% of capital is lost. The formula is:
    `Position Size = (Total Capital * 0.02) / (Entry Price - Stop Loss Price)`
4.  **Trailing Stop-Loss:** Once in a trade, the stop-loss is managed on every new candle. For a long position, the stop-loss can only move up; for a short, it can only move down. This allows the bot to lock in profits and ride trends for as long as possible. The trade is closed when the price hits this trailing stop.

### 6. Walk-Forward Training

The models are not trained once on all historical data. They are trained using a **Walk-Forward Validation** methodology. The trainer script simulates this process:
1.  Train on a 365-day window of data.
2.  Test on the next, unseen 30-day window.
3.  "Slide" the window forward by 30 days and repeat.
This ensures the models are robust and adapt to changing market conditions. The final models saved for the live bot are from the most recent training window.

---

## How to Use This Project

### 1. Installation

Clone the repository and install the required Python packages.

```bash
# Ensure you are in your project's root directory (e.g., C:\champ)
pip install -r requirements.txt
```

### 2. Initial Data Fetch

Run the `initial_data_fetcher.py` script once to download the complete 1-minute historical dataset for BTC/USDT. This will create the `data/btc_usdt_5y_1m.csv` file.

```bash
python initial_data_fetcher.py
```

### 3. Configuration

Open the `config.ini` file and fill in your credentials:
-   `[API]` section: Your Binance API Key and Secret.
-   `[TELEGRAM]` section: Your Telegram Bot Token and Chat ID.

### 4. Train the Models

Run the trainer script. This will perform the full backtest on your new data and save the final, trained models to the `/models` directory.

```bash
python src/trainer.py
```

### 5. Run the System

You will need two separate terminals, both navigated to your project's root directory.

**Terminal 1: Start the Live Bot**
This bot will run in paper trading mode by default.

```bash
python src/live_bot.py
```

**Terminal 2: Start the Dashboard**
This will launch the web-based monitoring UI.

```bash
python -m streamlit run src/dashboard.py
```
Open the URL provided by Streamlit (usually `http://localhost:8501`) in your web browser.

### 6. Updating the Algorithm

To keep the bot's models sharp, periodically (e.g., weekly or monthly):
1.  Run the data updater: `python src/update_data.py`
2.  Re-run the trainer: `python src/trainer.py`
3.  Restart the live bot: Stop `live_bot.py` with `Ctrl+C` and run it again. It will automatically load the new models.